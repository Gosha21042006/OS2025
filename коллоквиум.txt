1)
Объектно-ориентированное программирование (ООП) — это подход к разработке программного обеспечения, который является одним из инструментов борьбы со сложностью, в особенности с доменной сложностью. Несмотря на то, что теоретические основы ООП насчитывают около 2,5 тысяч лет, активное применение началось лишь в 80-е годы XX века в связи с принципиальным изменением характера решаемых доменных задач.

ООП представляет собой способ построения доменного "слоеного пирога" и является одним из воплощений фундаментального принципа "Разделяй и властвуй". В основе ООП лежат несколько ключевых концепций:

Инкапсуляция — основной способ борьбы со сложностью и изменчивостью, при котором между сложностью и изменчивостью существует естественное противоречие: скрывая изменчивость, мы увеличиваем сложность системы, по крайней мере локально. При этом изменчивость в 99% случаев имеет приоритет над сложностью.

Наследование и агрегация/композиция — два основных средства "художественной выразительности" в ООП, где наследование представляет собой частный, узкий случай реализации инкапсуляции.

Полиморфизм — также является вариантом реализации инкапсуляции и служит способом упрощения кода "клиента".

Абстракция/абстрагирование — универсальный инструмент любого варианта моделирования, включая не только ООП, но и процедурное, функциональное и другие парадигмы программирования.



2)
Процедурное программирование — это парадигма, в которой программа представляется в виде последовательности инструкций (процедур или подпрограмм), выполняемых для достижения результата. Основное внимание уделяется алгоритмам, а не данным.

Структурная декомпозиция — это ключевой метод проектирования в процедурном программировании, основанный на принципе «разделяй и властвуй». Сложная задача разбивается (декомпозируется) на более мелкие, логически связанные подзадачи. Эти подзадачи далее разбиваются на еще более мелкие, пока не будут получены элементарные, легко реализуемые процедуры (функции).



3) Архитектура ПО — это высокоуровневая структура системы, которая:

*Разбивает систему на компоненты (модули, сервисы, слои)

*Определяет границы между этими компонентами

*Организует взаимодействие между компонентами через четко определенные интерфейсы

Главная бизнес-задача архитектуры — удешевить проект на большом горизонте планирования, сделав максимально простой и дешевой разработку, развертывание, сопровождение, исправление ошибок и выпуск новых версий.

Ключевой принцип — откладывать принятие решений (выбор БД, технологий, способов развертывания) на как можно более поздний срок, чтобы сохранять максимальное разнообразие вариантов и принимать решения при наличии полной информации.

Плохой пример архитектуры
Ситибанк (исторический пример):

*Вся бизнес-логика по расчету кредитов была зашита в хранимых процедурах Oracle

*Система работала медленно и требовала дорогих лицензий

Когда переписали логику для работы с файловой системой вместо БД:

**Производительность выросла в разы, иногда на порядок

**Убрали дорогие лицензии Oracle

**Освободили серверы и специалистов

Хороший пример архитектуры
Финансовые системы на COBOL:

*Ядро финансовых систем, написанное в 60-70 годах, до сих пор работает

*Менялись только "плагины" — интерфейсы (от перфокарт → магнитных лент → веб-интерфейсов → мобильных приложений)

*Бизнес-правила (кредитование, вклады) остались неизменными

*Архитектура позволила менять технологии без переписывания ядра



4)Энтропия ПО - это неотвратимое превращение чистого кода в хаос. 

Примеры:

*Любой фикс по требованию заказчика добавляет новый костыль.

*Каждый новый разработчик приносит свой стиль написания кода.

*Библиотеки, от которых всё работало, внезапно становятся устаревшими и ломают всю систему.

5) Закон иерархических компенсаций  Седова
В формулировке, данной Назаретяном: в сложной иерархически организованной системе рост разнообразия на верхнем уровне системы обеспечивается ограничением разнообразия на предыдущих уровнях, и наоборот, рост разнообразия на нижнем уровне разрушает верхний уровень организации (т.е. система как таковая гибнет).

Примеры:
1) В 70е годы ежедневно появлялось несколько новых языков программирования то есть в год появлялось около 1000 новых языков, а программ в этот период было написано не намного больше, то есть верхним уровнем иерархии на тот момент были языки программирования поэтому на этом уровне было разнообразие, а вот программ конечные пользователи почти не видели.

2) Язык программирования С++, когда он появился, был вершиной иерархии и было множество реализаций, именно поэтому, например, 
игра quake 2 была написана не на С++, а на чистом С, хотя казалось бы на С писать дольше, дороже но на С было понятно как писать и уже было создано огромное количество программного обеспечения, а на С++ было понятно только как сделать С++  еще интереснее добавив новых библиотек, а вот как использовать его в мирных целях было непонятно.

3) Мобильные телефоны начала двухтысячных
огромное количество операционных систем и считанные программы, есть калькулятор, какой-нибудь ежедневник, три игры и все, вот операционных систем много а ПО мало.

4) На данный момент наоборот существует 2 основные ОС - Android и IOS, а различных программ ежедневно выходят сотни.   

5) Мы начинаем строить систему, разбиваем ее на слои и вдруг решаем давайте вот третий слой сверху у нас
будет разнообразным попробуем применить там это и это, добавим кучу функций которые будут торчать для других слоев и так далее все это обречено на неудачу.

6) У нас есть интернет который работает на считанных сетевых протоколах, причем это иерархия сетевых протоколов некая матрешка, добавив десяток новых сетевых протоколов мы не получим ничего ценного, а вот интернет наш работать перестанет и все что построено на его базе тоже. 

7) Компания наняла архитектора, который "всё упростил" - теперь для простого изменения нужно перелопатить пол-системы.